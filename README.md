# OrderBook-Matching-Engine
{"canmore.update\_textdoc": {"updates": \[{"pattern": ".\*", "multiple": true, "replacement": "# Orderbook Matching Engine in Rust\n\nThis is an educational project written in **Rust**, implementing a simple **orderbook** and **matching engine** similar to what is used in exchanges. The goal of the project is both to understand how an orderbook works (handling *limit* and *market* orders) and to deepen knowledge of Rust and its async ecosystem (`tokio`).\n\n---\n\n## ðŸ“Œ Main Features\n- Support for **Limit** and **Market** orders.\n- **Order matching engine**: matches buy (*Bid*) and sell (*Ask*) orders based on price and quantity.\n- Handles **multiple concurrent clients** over **TCP**.\n- Real-time **notifications** for clients when orders are **filled**, **partially filled**, or **unfilled**.\n- Live export of **traded prices** through a dedicated channel.\n- **CLI Client** with input validation and instant feedback.\n\n---\n\n## ðŸ“‚ Project Structure\n\n`text\n.\nâ”œâ”€â”€ Cargo.toml\nâ”œâ”€â”€ src\nâ”‚   â”œâ”€â”€ lib.rs             # Exposes project modules\nâ”‚   â”œâ”€â”€ orders.rs          # Order structures (LimitOrder, MarketOrder, etc.)\nâ”‚   â”œâ”€â”€ orderbook.rs       # Orderbook implementation and matching logic\nâ”‚   â”œâ”€â”€ client_handler.rs  # Handles client connections and communication channels\nâ”‚   â”œâ”€â”€ server.rs          # TCP server receiving orders and interacting with the orderbook\nâ”‚   â”œâ”€â”€ client.rs          # Interactive CLI client to send commands and read responses\nâ”‚   â”œâ”€â”€ test.rs            # Load-testing client spawner for benchmarking\nâ”‚   â””â”€â”€ orderbook_feeder.rs# Feeder for seeding the orderbook with random orders\n`\n\n---\n\n## ðŸš€ Running the Project\n\n### 1. Start the orderbook server\n`bash\ncargo run --bin server\n`\n\nThe server will listen on **127.0.0.1:8080** and accept client connections.\n\n### 2. Run the interactive client\n`bash\ncargo run --bin client\n`\n\nYou can send commands like:\n- **Market orders:**\n  `\n  buy market 50\n  sell market 30\n  `\n- **Limit orders:**\n  `\n  buy limit 120 10\n  sell limit 90 5\n  `\n\n### 3. Seed the orderbook with random orders (optional)\n`bash\ncargo run --bin orderbook_feeder\n`\n\n### 4. Run load testing with multiple clients\n`bash\ncargo run --bin test\n`\n\nThis will launch 100 concurrent clients sending random orders to the server.\n\n---\n\n## ðŸ“Š Performance (benchmarks)\n\nPerformance measurements:\n- With **50 existing orders** and **100 clients** connected â†’ \~**100 TPS** (transactions per second).\n- With **200 existing orders** and **750 clients** connected â†’ \~**500 TPS**.\n\n> Note: Performance can be improved by optimizing the internal data structures, reducing bottlenecks in `tokio::mpsc`, and possibly using more efficient matching algorithms.\n\n---\n\n## ðŸ”§ Technologies Used\n- **Rust** (safe, performant, systems-level)\n- **Tokio** â€“ async runtime for networking and concurrency\n- **Chrono** â€“ timestamps for orders\n- **BTreeMap & VecDeque** â€“ storage and fast access to orders\n- **Rand** â€“ generating random orders for testing\n\n---\n\n## ðŸ“– What I Learned\n- How a **real-world orderbook** works and the principles of a **matching engine**.\n- Handling **concurrent clients** using channels and async in Rust.\n- Differences between **market** and **limit** orders and their market impact.\n- Potential optimizations for scalability (higher TPS).\n- Organizing a modular Rust project with **multiple binaries** and a **shared crate library**.\n\n---\n\n## ðŸ›  Future Improvements\n- Persistent storage of orders and trades.\n- Support for **stop-loss** and **iceberg orders**.\n- WebSocket API instead of raw TCP.\n- Real-time web UI for orderbook visualization.\n- More detailed benchmarking and profiling for optimization.\n\n---\n\n## ðŸ“œ License\nThis project is for **educational purposes only** and is **not intended for production trading systems**.\n\n---\n\n## ðŸ‘¤ Author\nDeveloped to learn **Rust** and gain a deeper understanding of how a **matching engine** works."}]}}
